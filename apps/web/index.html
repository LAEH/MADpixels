<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MADpixels</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { background: #fbfbfd; color: #1d1d1f; -webkit-font-smoothing: antialiased; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', Helvetica, Arial, sans-serif; max-width: 980px; margin: 0 auto; padding: 80px 24px 120px; }

        header { text-align: center; margin-bottom: 80px; }
        .logo { font-size: 56px; font-weight: 700; letter-spacing: -0.03em; margin-bottom: 8px; }
        .logo span { background: linear-gradient(135deg, #1d1d1f, #6e6e73); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .subtitle { font-size: 21px; font-weight: 400; color: #6e6e73; letter-spacing: 0; }

        .hero { margin-bottom: 80px; text-align: center; }
        .hero-label { font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; color: #6e6e73; margin-bottom: 20px; }
        .hero canvas { max-width: 100%; height: auto; border-radius: 16px; display: block; margin: 0 auto; }

        .grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; }
        @media (max-width: 734px) { .grid { grid-template-columns: 1fr; gap: 16px; } }

        .card { background: #fff; border-radius: 20px; padding: 28px 28px 24px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.04), 0 4px 12px rgba(0,0,0,0.03); }
        .card-header { margin-bottom: 20px; }
        .card-name { font-size: 24px; font-weight: 600; letter-spacing: -0.01em; margin-bottom: 8px; color: #1d1d1f; }
        .card-name .idx { color: #86868b; font-size: 13px; font-weight: 500; margin-right: 8px; letter-spacing: 0; }
        .card-desc { font-size: 14px; line-height: 1.55; color: #6e6e73; font-weight: 400; }
        .card-desc code { color: #1d1d1f; background: rgba(0,0,0,0.04); padding: 2px 6px; border-radius: 4px; font-family: 'SF Mono', SFMono-Regular, ui-monospace, Menlo, monospace; font-size: 12px; }
        .card canvas { width: 100%; height: auto; border-radius: 12px; display: block; }
        .card .loading { color: #aeaeb2; font-size: 13px; font-family: 'SF Mono', SFMono-Regular, ui-monospace, Menlo, monospace; padding: 24px 0; }

        .footer { text-align: center; margin-top: 80px; color: #aeaeb2; font-size: 12px; }
    </style>
    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://madpixels.laeh.ai">
    <meta property="og:title" content="MADpixels">
    <meta property="og:description" content="Pixel manipulation art">
    <meta property="og:image" content="https://madpixels.laeh.ai/android-chrome-512x512.png">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="MADpixels">
    <meta name="twitter:description" content="Pixel manipulation art">
    <meta name="twitter:image" content="https://madpixels.laeh.ai/android-chrome-512x512.png">
  </head>
<body>
    <header>
        <div class="logo">MAD<span>pixels</span></div>
        <div class="subtitle">Pixel Manipulation Art</div>
    </header>

    <div class="hero">
        <div class="hero-label">Original</div>
        <canvas id="original"></canvas>
    </div>

    <div class="grid" id="grid"></div>

    <div class="footer">All transforms computed client-side with Canvas 2D.</div>

<script>
const TRANSFORMS = [
    {
        name: 'Invert',
        desc: 'Each channel flipped: <code>out = 255 - in</code>. Produces a color negative — bright becomes dark, red becomes cyan.',
        fn(src) {
            const out = new ImageData(new Uint8ClampedArray(src.data), src.width, src.height);
            const d = out.data;
            for (let i = 0; i < d.length; i += 4) {
                d[i] = 255 - d[i];
                d[i+1] = 255 - d[i+1];
                d[i+2] = 255 - d[i+2];
            }
            return out;
        }
    },
    {
        name: 'Boost',
        desc: 'Per-channel normalize to zero-mean / unit-variance, weight by <code>R:0.4 G:0.3 B:0.2</code>, then <code>tanh</code> soft-clip back to visible range. Produces saturated, film-like tones.',
        fn(src) {
            const w = src.width, h = src.height, n = w * h;
            const d = src.data;
            const out = new ImageData(new Uint8ClampedArray(d), w, h);
            const o = out.data;
            const weights = [0.4, 0.3, 0.2];
            for (let c = 0; c < 3; c++) {
                let sum = 0, sum2 = 0;
                for (let i = c; i < d.length; i += 4) { sum += d[i]; sum2 += d[i] * d[i]; }
                const mean = sum / n;
                const std = Math.sqrt(sum2 / n - mean * mean) || 1;
                const wt = weights[c];
                for (let i = c; i < d.length; i += 4) {
                    const norm = (d[i] - mean) / std;
                    const boosted = Math.tanh(norm * wt * 3);
                    o[i] = ((boosted + 1) / 2) * 255;
                }
            }
            return out;
        }
    },
    {
        name: 'Global Shuffle',
        desc: 'Fisher-Yates shuffle of every pixel position. The same colors exist — just scattered uniformly at random across the canvas. Produces static noise.',
        fn(src) {
            const w = src.width, h = src.height, n = w * h;
            const d = src.data;
            const out = new ImageData(new Uint8ClampedArray(d), w, h);
            const o = out.data;
            for (let i = n - 1; i > 0; i--) {
                const j = (Math.random() * (i + 1)) | 0;
                const si = i * 4, sj = j * 4;
                for (let c = 0; c < 4; c++) {
                    const tmp = o[si + c];
                    o[si + c] = o[sj + c];
                    o[sj + c] = tmp;
                }
            }
            return out;
        }
    },
    {
        name: 'Bin Shuffle',
        desc: 'Image divided into a <code>16&times;16</code> grid of blocks. Block positions shuffled randomly (Fisher-Yates on blocks). Each block stays intact — the mosaic is just rearranged.',
        fn(src) {
            const w = src.width, h = src.height;
            const bw = (w / 16) | 0, bh = (h / 16) | 0;
            const d = src.data;
            const out = new ImageData(new Uint8ClampedArray(d.length), w, h);
            const o = out.data;
            const indices = [];
            for (let i = 0; i < 256; i++) indices.push(i);
            for (let i = 255; i > 0; i--) {
                const j = (Math.random() * (i + 1)) | 0;
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }
            for (let i = 0; i < 256; i++) {
                const srcCol = (indices[i] % 16), srcRow = (indices[i] / 16) | 0;
                const dstCol = (i % 16), dstRow = (i / 16) | 0;
                for (let y = 0; y < bh; y++) {
                    for (let x = 0; x < bw; x++) {
                        const si = ((srcRow * bh + y) * w + srcCol * bw + x) * 4;
                        const di = ((dstRow * bh + y) * w + dstCol * bw + x) * 4;
                        if (si < d.length && di < o.length) {
                            o[di] = d[si]; o[di+1] = d[si+1]; o[di+2] = d[si+2]; o[di+3] = d[si+3];
                        }
                    }
                }
            }
            return out;
        }
    },
    {
        name: 'Local Shuffle',
        desc: 'Each pixel displaced by a Gaussian random offset (Box-Muller transform, &sigma;=8px). Nearby pixels stay roughly nearby — gives a frosted-glass or heat-shimmer effect.',
        fn(src) {
            const w = src.width, h = src.height;
            const d = src.data;
            const out = new ImageData(new Uint8ClampedArray(d.length), w, h);
            const o = out.data;
            const sigma = 8;
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const u1 = Math.max(1e-10, Math.random());
                    const u2 = Math.random();
                    const mag = sigma * Math.sqrt(-2 * Math.log(u1));
                    const dx = Math.round(mag * Math.cos(2 * Math.PI * u2));
                    const dy = Math.round(mag * Math.sin(2 * Math.PI * u2));
                    const sx = Math.max(0, Math.min(w - 1, x + dx));
                    const sy = Math.max(0, Math.min(h - 1, y + dy));
                    const si = (sy * w + sx) * 4;
                    const di = (y * w + x) * 4;
                    o[di] = d[si]; o[di+1] = d[si+1]; o[di+2] = d[si+2]; o[di+3] = 255;
                }
            }
            return out;
        }
    },
    {
        name: 'Bined Color Shuffle',
        desc: 'Sample 100 colors from the image. Fill <code>32px</code> blocks, each assigned the nearest sampled color with random HSL jitter (&plusmn;15&deg; hue, &plusmn;10% sat/light). An impressionist mosaic.',
        fn(src) {
            const w = src.width, h = src.height;
            const d = src.data;
            const out = new ImageData(new Uint8ClampedArray(d.length), w, h);
            const o = out.data;
            // sample 100 colors
            const palette = [];
            for (let i = 0; i < 100; i++) {
                const idx = ((Math.random() * w * h) | 0) * 4;
                palette.push([d[idx], d[idx+1], d[idx+2]]);
            }
            function rgbToHsl(r, g, b) {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                if (max === min) { h = s = 0; }
                else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                    else if (max === g) h = ((b - r) / d + 2) / 6;
                    else h = ((r - g) / d + 4) / 6;
                }
                return [h * 360, s * 100, l * 100];
            }
            function hslToRgb(h, s, l) {
                h /= 360; s /= 100; l /= 100;
                let r, g, b;
                if (s === 0) { r = g = b = l; }
                else {
                    const hue2rgb = (p, q, t) => { if (t < 0) t += 1; if (t > 1) t -= 1; if (t < 1/6) return p + (q - p) * 6 * t; if (t < 1/2) return q; if (t < 2/3) return p + (q - p) * (2/3 - t) * 6; return p; };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                return [(r * 255) | 0, (g * 255) | 0, (b * 255) | 0];
            }
            const bs = 32;
            for (let by = 0; by < h; by += bs) {
                for (let bx = 0; bx < w; bx += bs) {
                    // average color of this block
                    let rr = 0, gg = 0, bb = 0, cnt = 0;
                    for (let y = by; y < Math.min(by + bs, h); y++) {
                        for (let x = bx; x < Math.min(bx + bs, w); x++) {
                            const i = (y * w + x) * 4;
                            rr += d[i]; gg += d[i+1]; bb += d[i+2]; cnt++;
                        }
                    }
                    rr = (rr / cnt) | 0; gg = (gg / cnt) | 0; bb = (bb / cnt) | 0;
                    // find nearest palette color
                    let best = 0, bestDist = Infinity;
                    for (let p = 0; p < palette.length; p++) {
                        const dr = rr - palette[p][0], dg = gg - palette[p][1], db = bb - palette[p][2];
                        const dist = dr*dr + dg*dg + db*db;
                        if (dist < bestDist) { bestDist = dist; best = p; }
                    }
                    const [pr, pg, pb] = palette[best];
                    let [hh, ss, ll] = rgbToHsl(pr, pg, pb);
                    hh += (Math.random() - 0.5) * 30;
                    ss = Math.max(0, Math.min(100, ss + (Math.random() - 0.5) * 20));
                    ll = Math.max(0, Math.min(100, ll + (Math.random() - 0.5) * 20));
                    const [fr, fg, fb] = hslToRgb(hh, ss, ll);
                    for (let y = by; y < Math.min(by + bs, h); y++) {
                        for (let x = bx; x < Math.min(bx + bs, w); x++) {
                            const i = (y * w + x) * 4;
                            o[i] = fr; o[i+1] = fg; o[i+2] = fb; o[i+3] = 255;
                        }
                    }
                }
            }
            return out;
        }
    },
    {
        name: 'Gaussian Blur',
        desc: 'Separable 1D Gaussian kernel (&sigma;=6, radius 18). Two passes — horizontal then vertical. Each pixel becomes the weighted average of its neighbors. Classic low-pass filter.',
        fn(src) {
            const w = src.width, h = src.height;
            const d = src.data;
            const sigma = 6, radius = Math.ceil(sigma * 3);
            // build kernel
            const kernel = [];
            let ksum = 0;
            for (let i = -radius; i <= radius; i++) {
                const v = Math.exp(-(i * i) / (2 * sigma * sigma));
                kernel.push(v);
                ksum += v;
            }
            for (let i = 0; i < kernel.length; i++) kernel[i] /= ksum;

            // horizontal pass
            const tmp = new Float32Array(w * h * 4);
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    let r = 0, g = 0, b = 0;
                    for (let k = -radius; k <= radius; k++) {
                        const sx = Math.max(0, Math.min(w - 1, x + k));
                        const si = (y * w + sx) * 4;
                        const wt = kernel[k + radius];
                        r += d[si] * wt;
                        g += d[si + 1] * wt;
                        b += d[si + 2] * wt;
                    }
                    const di = (y * w + x) * 4;
                    tmp[di] = r; tmp[di+1] = g; tmp[di+2] = b; tmp[di+3] = 255;
                }
            }
            // vertical pass
            const out = new ImageData(new Uint8ClampedArray(d.length), w, h);
            const o = out.data;
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    let r = 0, g = 0, b = 0;
                    for (let k = -radius; k <= radius; k++) {
                        const sy = Math.max(0, Math.min(h - 1, y + k));
                        const si = (sy * w + x) * 4;
                        const wt = kernel[k + radius];
                        r += tmp[si] * wt;
                        g += tmp[si + 1] * wt;
                        b += tmp[si + 2] * wt;
                    }
                    const di = (y * w + x) * 4;
                    o[di] = r; o[di+1] = g; o[di+2] = b; o[di+3] = 255;
                }
            }
            return out;
        }
    }
];

const grid = document.getElementById('grid');
const cards = [];

TRANSFORMS.forEach((t, i) => {
    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `
        <div class="card-header">
            <div class="card-name"><span class="idx">${String(i + 1).padStart(2, '0')}</span>${t.name}</div>
            <div class="card-desc">${t.desc}</div>
        </div>
        <canvas></canvas>
        <div class="loading">computing...</div>
    `;
    grid.appendChild(card);
    cards.push(card);
});

const img = new Image();
img.onload = () => {
    // draw original
    const origCanvas = document.getElementById('original');
    origCanvas.width = img.width;
    origCanvas.height = img.height;
    const origCtx = origCanvas.getContext('2d');
    origCtx.drawImage(img, 0, 0);
    const srcData = origCtx.getImageData(0, 0, img.width, img.height);

    // stagger transforms
    TRANSFORMS.forEach((t, i) => {
        setTimeout(() => {
            const card = cards[i];
            const canvas = card.querySelector('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            const result = t.fn(srcData);
            ctx.putImageData(result, 0, 0);
            card.querySelector('.loading').style.display = 'none';
        }, i * 200);
    });
};
img.src = 'img/rick2.jpg';
</script>
</body>
</html>
