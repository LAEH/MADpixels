<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MADpixels</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { height: 100%; overflow: hidden; }

        body {
            font-family: 'Space Grotesk', -apple-system, sans-serif;
            background: #fff;
            color: #000;
        }

        .app {
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: env(safe-area-inset-top) 0 env(safe-area-inset-bottom) 0;
        }

        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            flex-shrink: 0;
        }

        .logo {
            font-size: 20px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .icon-btn {
            width: 48px;
            height: 48px;
            border: 2px solid #000;
            background: #fff;
            color: #000;
            border-radius: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .icon-btn:active { background: #000; color: #fff; }
        .icon-btn:disabled { opacity: 0.2; }
        .icon-btn svg { width: 22px; height: 22px; }

        .canvas-wrap {
            flex: 1;
            min-height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 16px;
            position: relative;
            cursor: pointer;
        }

        .canvas-wrap canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
        }

        .tap-hint {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: rgba(0,0,0,0.8);
            color: #fff;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .canvas-wrap:hover .tap-hint { opacity: 1; }

        .controls {
            flex-shrink: 0;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .slider-label {
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
        }

        .slider-value {
            font-size: 14px;
            font-weight: 700;
            color: #000;
            min-width: 40px;
            text-align: right;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 48px;
            background: transparent;
            margin: 0;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 32px;
            height: 32px;
            background: #000;
            border-radius: 50%;
            margin-top: -12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .btn-row {
            display: flex;
            gap: 12px;
        }

        .reveal-btn {
            flex: 1;
            height: 56px;
            border: 2px solid #000;
            border-radius: 28px;
            background: #fff;
            color: #000;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 15px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .reveal-btn:active { background: #f0f0f0; }
        .reveal-btn.active {
            background: #000;
            color: #fff;
        }

        .shuffle-btn {
            flex: 1;
            height: 56px;
            border: none;
            border-radius: 28px;
            background: #000;
            color: #fff;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 15px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .shuffle-btn:active { opacity: 0.85; }

        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="app">
        <header>
            <span class="logo">MADpixels</span>
            <button class="icon-btn" id="downloadBtn">
                <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
                </svg>
            </button>
        </header>

        <div class="canvas-wrap" id="canvasArea">
            <canvas id="canvas"></canvas>
            <canvas id="glCanvas" class="hidden"></canvas>
            <span class="tap-hint">Tap to change photo</span>
        </div>

        <div class="controls">
            <div class="slider-group">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Block Size</span>
                        <span class="slider-value" id="blockValue">8</span>
                    </div>
                    <input type="range" id="blockSlider" min="2" max="64" value="8" step="2">
                </div>

                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Dispersion</span>
                        <span class="slider-value" id="disperseValue">0</span>
                    </div>
                    <input type="range" id="disperseSlider" min="0" max="100" value="0" step="5">
                </div>
            </div>

            <div class="btn-row">
                <button class="reveal-btn" id="revealBtn">Reveal</button>
                <button class="shuffle-btn" id="shuffleBtn">Shuffle</button>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept="image/*" style="display:none">

<script>
class WebGLProcessor {
    constructor() {
        this.canvas = document.getElementById('glCanvas');
        this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl');
        this.programs = {};
        this.available = !!this.gl;
        if (this.available) this.init();
    }

    init() {
        const gl = this.gl;
        const vert = `attribute vec2 a_position;attribute vec2 a_texCoord;varying vec2 v_texCoord;void main(){gl_Position=vec4(a_position,0,1);v_texCoord=a_texCoord;}`;
        const shaders = {
            localShuffle: `precision highp float;varying vec2 v_texCoord;uniform sampler2D u_image;uniform vec2 u_res;uniform float u_spread;uniform float u_seed;float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453+u_seed);}void main(){float m=max(u_res.x,u_res.y)*u_spread/4.0;float u1=max(0.0001,hash(v_texCoord*u_res));float u2=hash(v_texCoord*u_res+vec2(1.0,0.0));float r=sqrt(-2.0*log(u1));vec2 n=vec2(r*cos(6.28318*u2),r*sin(6.28318*u2))*m/u_res;gl_FragColor=texture2D(u_image,clamp(v_texCoord+n,0.0,1.0));}`
        };
        for (const [name, frag] of Object.entries(shaders)) {
            const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, vert); gl.compileShader(vs);
            const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, frag); gl.compileShader(fs);
            const prog = gl.createProgram(); gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog);
            this.programs[name] = prog;
        }
        this.posBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);
        this.texBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,1,1,1,0,0,0,0,1,1,1,0]), gl.STATIC_DRAW);
    }

    createTexture(img) {
        const gl = this.gl, tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        return tex;
    }

    render(prog, w, h, setup) {
        const gl = this.gl;
        this.canvas.width = w; this.canvas.height = h;
        gl.viewport(0, 0, w, h); gl.useProgram(prog);
        const pLoc = gl.getAttribLocation(prog, 'a_position');
        gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuf); gl.enableVertexAttribArray(pLoc); gl.vertexAttribPointer(pLoc, 2, gl.FLOAT, false, 0, 0);
        const tLoc = gl.getAttribLocation(prog, 'a_texCoord');
        gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuf); gl.enableVertexAttribArray(tLoc); gl.vertexAttribPointer(tLoc, 2, gl.FLOAT, false, 0, 0);
        setup(gl, prog); gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    getImageData() {
        const gl = this.gl, w = this.canvas.width, h = this.canvas.height;
        const px = new Uint8Array(w * h * 4);
        gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, px);
        const flip = new Uint8ClampedArray(px.length);
        for (let y = 0; y < h; y++) flip.set(px.subarray((h-1-y)*w*4, (h-y)*w*4), y*w*4);
        return new ImageData(flip, w, h);
    }

    localShuffle(img, spread, seed) {
        const t = this.createTexture(img);
        this.render(this.programs.localShuffle, img.width, img.height, (gl, p) => {
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, t);
            gl.uniform1i(gl.getUniformLocation(p, 'u_image'), 0);
            gl.uniform2f(gl.getUniformLocation(p, 'u_res'), img.width, img.height);
            gl.uniform1f(gl.getUniformLocation(p, 'u_spread'), spread);
            gl.uniform1f(gl.getUniformLocation(p, 'u_seed'), seed);
        });
        this.gl.deleteTexture(t);
        return this.getImageData();
    }
}

// State
let originalImage = null;
let shuffledBlocks = null;
let blockSize = 8;
let dispersion = 0;
let seed = Math.random() * 1000;
let isRevealed = false;

const $ = id => document.getElementById(id);
const canvas = $('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const gpu = new WebGLProcessor();

// Create sample image - colorful abstract
function createSampleImage() {
    const size = 512;
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const cx = c.getContext('2d');

    // Create interesting gradient
    const g1 = cx.createLinearGradient(0, 0, size, size);
    g1.addColorStop(0, '#FF6B6B');
    g1.addColorStop(0.5, '#4ECDC4');
    g1.addColorStop(1, '#45B7D1');
    cx.fillStyle = g1;
    cx.fillRect(0, 0, size, size);

    // Add some circles for interest
    const g2 = cx.createRadialGradient(size*0.3, size*0.3, 0, size*0.3, size*0.3, size*0.4);
    g2.addColorStop(0, 'rgba(255,255,255,0.8)');
    g2.addColorStop(1, 'rgba(255,255,255,0)');
    cx.fillStyle = g2;
    cx.fillRect(0, 0, size, size);

    const g3 = cx.createRadialGradient(size*0.7, size*0.6, 0, size*0.7, size*0.6, size*0.3);
    g3.addColorStop(0, 'rgba(147,51,234,0.7)');
    g3.addColorStop(1, 'rgba(147,51,234,0)');
    cx.fillStyle = g3;
    cx.fillRect(0, 0, size, size);

    return cx.getImageData(0, 0, size, size);
}

// Bin shuffle - scramble blocks
function binShuffle(img, blockSize, seedVal) {
    const w = img.width, h = img.height;
    const data = new Uint8ClampedArray(img.data);
    const out = new Uint8ClampedArray(data.length);

    const bx = Math.floor(w / blockSize);
    const by = Math.floor(h / blockSize);
    const totalBlocks = bx * by;

    // Create shuffled indices
    const indices = [];
    for (let i = 0; i < totalBlocks; i++) indices.push(i);

    // Seeded shuffle
    const rng = (s) => { s = Math.sin(s) * 10000; return s - Math.floor(s); };
    let s = seedVal;
    for (let i = indices.length - 1; i > 0; i--) {
        s = rng(s + i);
        const j = Math.floor(s * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
    }

    // Copy blocks to shuffled positions
    for (let i = 0; i < totalBlocks; i++) {
        const srcIdx = indices[i];
        const srcX = (srcIdx % bx) * blockSize;
        const srcY = Math.floor(srcIdx / bx) * blockSize;
        const dstX = (i % bx) * blockSize;
        const dstY = Math.floor(i / bx) * blockSize;

        for (let y = 0; y < blockSize; y++) {
            for (let x = 0; x < blockSize; x++) {
                const si = ((srcY + y) * w + srcX + x) * 4;
                const di = ((dstY + y) * w + dstX + x) * 4;
                out[di] = data[si];
                out[di+1] = data[si+1];
                out[di+2] = data[si+2];
                out[di+3] = data[si+3];
            }
        }
    }

    return new ImageData(out, w, h);
}

// Apply current effect
function applyEffect() {
    if (!originalImage) return;

    // First bin shuffle
    let result = binShuffle(originalImage, blockSize, seed);

    // Then apply dispersion if any
    if (dispersion > 0 && gpu.available) {
        result = gpu.localShuffle(result, dispersion / 100, seed);
    }

    shuffledBlocks = result;
    display(result);
}

function display(data) {
    if (!data) return;
    canvas.width = data.width;
    canvas.height = data.height;
    ctx.putImageData(data, 0, 0);
}

function loadImage(file) {
    const reader = new FileReader();
    reader.onload = e => {
        const img = new Image();
        img.onload = () => {
            // Resize to square for clean blocks
            const size = 512;
            const c = document.createElement('canvas');
            c.width = size; c.height = size;
            const cx = c.getContext('2d');

            // Cover fit
            const scale = Math.max(size / img.width, size / img.height);
            const w = img.width * scale;
            const h = img.height * scale;
            cx.drawImage(img, (size - w) / 2, (size - h) / 2, w, h);

            originalImage = cx.getImageData(0, 0, size, size);
            seed = Math.random() * 1000;
            isRevealed = false;
            $('revealBtn').classList.remove('active');
            applyEffect();
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

function newShuffle() {
    seed = Math.random() * 1000;
    isRevealed = false;
    $('revealBtn').classList.remove('active');
    applyEffect();
}

function toggleReveal() {
    isRevealed = !isRevealed;
    $('revealBtn').classList.toggle('active', isRevealed);
    display(isRevealed ? originalImage : shuffledBlocks);
}

// Events
$('canvasArea').onclick = () => $('fileInput').click();
$('fileInput').onchange = e => e.target.files[0] && loadImage(e.target.files[0]);

$('blockSlider').oninput = e => {
    blockSize = parseInt(e.target.value);
    $('blockValue').textContent = blockSize;
    if (!isRevealed) applyEffect();
};

$('disperseSlider').oninput = e => {
    dispersion = parseInt(e.target.value);
    $('disperseValue').textContent = dispersion;
    if (!isRevealed) applyEffect();
};

$('revealBtn').onclick = toggleReveal;
$('shuffleBtn').onclick = newShuffle;

$('downloadBtn').onclick = () => {
    const a = document.createElement('a');
    a.download = `madpixels-${Date.now()}.png`;
    a.href = canvas.toDataURL('image/png');
    a.click();
};

// Init with sample
originalImage = createSampleImage();
applyEffect();
</script>
</body>
</html>
