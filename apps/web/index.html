<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MADpixels - Artistic Image Effects</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0a0a0f">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --primary: #d951f9;
            --primary-dark: #b030d9;
            --bg: #0a0a0f;
            --surface: #16161f;
            --surface-light: #1e1e2a;
            --text: #ffffff;
            --text-secondary: #a0a0b0;
            --border: #2a2a3a;
            --success: #4ade80;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }
        header {
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        .logo {
            font-size: 1.25rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), #66ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .gpu-badge {
            font-size: 0.6rem;
            padding: 2px 6px;
            background: var(--success);
            color: #000;
            border-radius: 4px;
            margin-left: 8px;
            font-weight: 600;
        }
        .header-actions { display: flex; gap: 0.5rem; }
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 0.75rem;
            gap: 0.75rem;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }
        .canvas-container {
            flex: 1;
            background: var(--surface);
            border-radius: 12px;
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 200px;
            position: relative;
            overflow: hidden;
            touch-action: none;
        }
        .canvas-container canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        .placeholder {
            text-align: center;
            color: var(--text-secondary);
            padding: 2rem;
        }
        .placeholder-icon { font-size: 3rem; margin-bottom: 0.75rem; opacity: 0.5; }
        .compare-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            padding: 0.5rem;
        }
        .compare-toggle span { font-size: 0.8rem; color: var(--text-secondary); transition: all 0.2s; }
        .compare-toggle span.active { color: var(--text); font-weight: 600; }
        .toggle-switch { position: relative; width: 44px; height: 24px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            inset: 0;
            background: var(--surface-light);
            border-radius: 24px;
            transition: 0.2s;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background: white;
            border-radius: 50%;
            transition: 0.2s;
        }
        .toggle-switch input:checked + .toggle-slider { background: var(--primary); }
        .toggle-switch input:checked + .toggle-slider:before { transform: translateX(20px); }
        .controls {
            background: var(--surface);
            border-radius: 12px;
            border: 1px solid var(--border);
            padding: 0.75rem;
        }
        .categories {
            display: flex;
            gap: 0.4rem;
            margin-bottom: 0.75rem;
            overflow-x: auto;
            padding-bottom: 0.4rem;
            -webkit-overflow-scrolling: touch;
        }
        .categories::-webkit-scrollbar { display: none; }
        .category-btn {
            padding: 0.4rem 0.8rem;
            border-radius: 16px;
            border: none;
            background: var(--surface-light);
            color: var(--text);
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            white-space: nowrap;
            transition: all 0.15s;
            -webkit-tap-highlight-color: transparent;
        }
        .category-btn:hover { background: var(--border); }
        .category-btn.active { background: var(--primary); color: white; }
        .effects {
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
            margin-bottom: 0.75rem;
        }
        .effect-btn {
            padding: 0.35rem 0.7rem;
            border-radius: 6px;
            border: 1px solid transparent;
            background: var(--surface-light);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.15s;
            -webkit-tap-highlight-color: transparent;
        }
        .effect-btn:hover { background: var(--border); color: var(--text); }
        .effect-btn.active {
            background: rgba(217, 81, 249, 0.15);
            border-color: var(--primary);
            color: var(--primary);
        }
        .settings-section {
            margin-bottom: 0.75rem;
            padding: 0.75rem;
            background: var(--surface-light);
            border-radius: 8px;
        }
        .settings-section h3 {
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.4rem;
        }
        .setting-row:last-child { margin-bottom: 0; }
        .setting-row label { font-size: 0.75rem; color: var(--text-secondary); }
        .setting-row input[type="range"] {
            width: 100px;
            height: 4px;
            accent-color: var(--primary);
            cursor: pointer;
        }
        .setting-row span {
            font-size: 0.7rem;
            color: var(--text);
            min-width: 35px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }
        .btn {
            padding: 0.7rem 1.25rem;
            border-radius: 10px;
            border: none;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            -webkit-tap-highlight-color: transparent;
        }
        .btn-primary {
            background: var(--primary);
            color: white;
            width: 100%;
        }
        .btn-primary:hover { background: var(--primary-dark); transform: translateY(-1px); }
        .btn-primary:active { transform: translateY(0); }
        .btn-primary:disabled {
            background: var(--border);
            color: var(--text-secondary);
            cursor: not-allowed;
            transform: none;
        }
        .btn-secondary {
            background: var(--surface-light);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 0.5rem 0.75rem;
            font-size: 0.8rem;
        }
        .btn-secondary:hover { background: var(--border); }
        .btn-secondary svg { width: 16px; height: 16px; }
        .progress-container { margin-top: 0.75rem; display: none; }
        .progress-container.visible { display: block; }
        .progress-bar {
            height: 3px;
            background: var(--surface-light);
            border-radius: 2px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), #66ccff);
            width: 0%;
            transition: width 0.05s linear;
        }
        .progress-text {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 0.4rem;
            font-variant-numeric: tabular-nums;
        }
        .perf-stats {
            font-size: 0.65rem;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 0.25rem;
        }
        .hidden-input { display: none; }
        .drop-zone {
            position: absolute;
            inset: 0;
            background: rgba(217, 81, 249, 0.1);
            border: 2px dashed var(--primary);
            border-radius: 12px;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            color: var(--primary);
            font-weight: 500;
        }
        .drop-zone.active { display: flex; }
        @media (min-width: 768px) {
            main {
                flex-direction: row;
                padding: 1.25rem;
                gap: 1.25rem;
            }
            .canvas-container { flex: 2; min-height: 500px; }
            .controls { flex: 1; max-width: 320px; }
            header { padding: 1rem 1.5rem; }
            .logo { font-size: 1.4rem; }
        }
        @media (max-width: 767px) {
            .canvas-container { min-height: 220px; max-height: 45vh; }
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .processing .btn-primary { animation: pulse 1s infinite; }
    </style>
</head>
<body>
    <header>
        <div style="display: flex; align-items: center;">
            <div class="logo">MADpixels</div>
            <span class="gpu-badge" id="gpuBadge" style="display: none;">WebGL</span>
        </div>
        <div class="header-actions">
            <button class="btn btn-secondary" id="uploadBtn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                    <circle cx="8.5" cy="8.5" r="1.5"/>
                    <polyline points="21 15 16 10 5 21"/>
                </svg>
                <span class="btn-text">Upload</span>
            </button>
            <button class="btn btn-secondary" id="downloadBtn" disabled>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
                <span class="btn-text">Save</span>
            </button>
        </div>
    </header>

    <main>
        <div class="canvas-container" id="canvasContainer">
            <canvas id="canvas"></canvas>
            <canvas id="glCanvas" style="display:none;"></canvas>
            <div class="placeholder" id="placeholder">
                <div class="placeholder-icon">ðŸŽ¨</div>
                <p>Drop an image or tap Upload</p>
            </div>
            <div class="drop-zone" id="dropZone">Drop image here</div>
        </div>

        <div class="controls">
            <div class="compare-toggle" id="compareToggle" style="display: none;">
                <span id="originalLabel">Original</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="compareSwitch" checked>
                    <span class="toggle-slider"></span>
                </label>
                <span id="processedLabel" class="active">Processed</span>
            </div>

            <div class="categories" id="categories"></div>
            <div class="effects" id="effectsContainer"></div>

            <div class="settings-section" id="settingsSection">
                <h3>Settings</h3>
                <div id="settingsContainer"></div>
            </div>

            <button class="btn btn-primary" id="applyBtn" disabled>
                <span id="applyBtnText">Apply Effect</span>
            </button>

            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Processing... 0%</div>
                <div class="perf-stats" id="perfStats"></div>
            </div>
        </div>
    </main>

    <input type="file" id="fileInput" class="hidden-input" accept="image/*">

    <script>
    // ============================================
    // WebGL GPU Processor
    // ============================================
    class WebGLProcessor {
        constructor() {
            this.canvas = document.getElementById('glCanvas');
            this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl');
            this.programs = {};
            this.available = !!this.gl;

            if (this.available) {
                this.init();
                document.getElementById('gpuBadge').style.display = 'inline';
            }
        }

        init() {
            const gl = this.gl;

            // Vertex shader (shared)
            const vertexShaderSrc = `
                attribute vec2 a_position;
                attribute vec2 a_texCoord;
                varying vec2 v_texCoord;
                void main() {
                    gl_Position = vec4(a_position, 0, 1);
                    v_texCoord = a_texCoord;
                }
            `;

            // Fragment shaders for each effect
            const shaders = {
                invert: `
                    precision mediump float;
                    varying vec2 v_texCoord;
                    uniform sampler2D u_image;
                    void main() {
                        vec4 color = texture2D(u_image, v_texCoord);
                        gl_FragColor = vec4(1.0 - color.rgb, color.a);
                    }
                `,
                boost: `
                    precision mediump float;
                    varying vec2 v_texCoord;
                    uniform sampler2D u_image;
                    uniform vec3 u_boost;
                    void main() {
                        vec4 color = texture2D(u_image, v_texCoord);
                        vec3 normalized = (color.rgb - 0.5) * u_boost * 4.0;
                        vec3 clipped = (tanh(normalized) + 1.0) * 0.5;
                        gl_FragColor = vec4(clipped, color.a);
                    }
                    vec3 tanh(vec3 x) {
                        vec3 e2x = exp(2.0 * x);
                        return (e2x - 1.0) / (e2x + 1.0);
                    }
                `,
                blur: `
                    precision mediump float;
                    varying vec2 v_texCoord;
                    uniform sampler2D u_image;
                    uniform vec2 u_resolution;
                    uniform float u_radius;
                    uniform vec2 u_direction;
                    void main() {
                        vec4 sum = vec4(0.0);
                        float total = 0.0;
                        for (float i = -20.0; i <= 20.0; i += 1.0) {
                            float weight = exp(-i * i / (2.0 * u_radius * u_radius));
                            vec2 offset = u_direction * i / u_resolution;
                            sum += texture2D(u_image, v_texCoord + offset) * weight;
                            total += weight;
                        }
                        gl_FragColor = sum / total;
                    }
                `,
                localShuffle: `
                    precision highp float;
                    varying vec2 v_texCoord;
                    uniform sampler2D u_image;
                    uniform vec2 u_resolution;
                    uniform float u_spread;
                    uniform float u_seed;

                    float hash(vec2 p) {
                        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453 + u_seed);
                    }

                    vec2 gaussianNoise(vec2 p) {
                        float u1 = max(0.0001, hash(p));
                        float u2 = hash(p + vec2(1.0, 0.0));
                        float r = sqrt(-2.0 * log(u1));
                        float theta = 6.28318 * u2;
                        return vec2(r * cos(theta), r * sin(theta));
                    }

                    void main() {
                        float maxSpread = max(u_resolution.x, u_resolution.y) * u_spread / 4.0;
                        vec2 noise = gaussianNoise(v_texCoord * u_resolution) * maxSpread / u_resolution;
                        vec2 srcCoord = clamp(v_texCoord + noise, 0.0, 1.0);
                        gl_FragColor = texture2D(u_image, srcCoord);
                    }
                `,
                gradient: `
                    precision mediump float;
                    varying vec2 v_texCoord;
                    uniform vec4 u_tl, u_tr, u_bl, u_br;
                    void main() {
                        vec4 top = mix(u_tl, u_tr, v_texCoord.x);
                        vec4 bottom = mix(u_bl, u_br, v_texCoord.x);
                        gl_FragColor = mix(top, bottom, v_texCoord.y);
                    }
                `
            };

            // Compile shaders
            for (const [name, fragSrc] of Object.entries(shaders)) {
                this.programs[name] = this.createProgram(vertexShaderSrc, fragSrc);
            }

            // Create buffers
            this.positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 1, -1, -1, 1,
                -1, 1, 1, -1, 1, 1
            ]), gl.STATIC_DRAW);

            this.texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0, 1, 1, 1, 0, 0,
                0, 0, 1, 1, 1, 0
            ]), gl.STATIC_DRAW);
        }

        createProgram(vertSrc, fragSrc) {
            const gl = this.gl;
            const vert = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vert, vertSrc);
            gl.compileShader(vert);

            const frag = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(frag, fragSrc);
            gl.compileShader(frag);

            const program = gl.createProgram();
            gl.attachShader(program, vert);
            gl.attachShader(program, frag);
            gl.linkProgram(program);

            return program;
        }

        createTexture(imageData) {
            const gl = this.gl;
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
            return texture;
        }

        render(program, width, height, setupUniforms) {
            const gl = this.gl;
            this.canvas.width = width;
            this.canvas.height = height;
            gl.viewport(0, 0, width, height);

            gl.useProgram(program);

            const posLoc = gl.getAttribLocation(program, 'a_position');
            gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            const texLoc = gl.getAttribLocation(program, 'a_texCoord');
            gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
            gl.enableVertexAttribArray(texLoc);
            gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);

            setupUniforms(gl, program);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        getImageData() {
            const gl = this.gl;
            const pixels = new Uint8Array(this.canvas.width * this.canvas.height * 4);
            gl.readPixels(0, 0, this.canvas.width, this.canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

            // Flip vertically
            const flipped = new Uint8ClampedArray(pixels.length);
            const rowSize = this.canvas.width * 4;
            for (let y = 0; y < this.canvas.height; y++) {
                const srcRow = (this.canvas.height - 1 - y) * rowSize;
                const dstRow = y * rowSize;
                flipped.set(pixels.subarray(srcRow, srcRow + rowSize), dstRow);
            }

            return new ImageData(flipped, this.canvas.width, this.canvas.height);
        }

        // GPU Effects
        invert(imageData) {
            const texture = this.createTexture(imageData);
            this.render(this.programs.invert, imageData.width, imageData.height, (gl, prog) => {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_image'), 0);
            });
            gl.deleteTexture(texture);
            return this.getImageData();
        }

        boost(imageData, r, g, b) {
            const texture = this.createTexture(imageData);
            this.render(this.programs.boost, imageData.width, imageData.height, (gl, prog) => {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_image'), 0);
                gl.uniform3f(gl.getUniformLocation(prog, 'u_boost'), r, g, b);
            });
            this.gl.deleteTexture(texture);
            return this.getImageData();
        }

        blur(imageData, radius) {
            const gl = this.gl;
            // Two-pass separable blur
            let texture = this.createTexture(imageData);

            // Horizontal pass
            this.render(this.programs.blur, imageData.width, imageData.height, (gl, prog) => {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_image'), 0);
                gl.uniform2f(gl.getUniformLocation(prog, 'u_resolution'), imageData.width, imageData.height);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_radius'), radius);
                gl.uniform2f(gl.getUniformLocation(prog, 'u_direction'), 1, 0);
            });

            const intermediate = this.getImageData();
            gl.deleteTexture(texture);
            texture = this.createTexture(intermediate);

            // Vertical pass
            this.render(this.programs.blur, imageData.width, imageData.height, (gl, prog) => {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_image'), 0);
                gl.uniform2f(gl.getUniformLocation(prog, 'u_resolution'), imageData.width, imageData.height);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_radius'), radius);
                gl.uniform2f(gl.getUniformLocation(prog, 'u_direction'), 0, 1);
            });

            gl.deleteTexture(texture);
            return this.getImageData();
        }

        localShuffle(imageData, spread) {
            const texture = this.createTexture(imageData);
            this.render(this.programs.localShuffle, imageData.width, imageData.height, (gl, prog) => {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(gl.getUniformLocation(prog, 'u_image'), 0);
                gl.uniform2f(gl.getUniformLocation(prog, 'u_resolution'), imageData.width, imageData.height);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_spread'), spread);
                gl.uniform1f(gl.getUniformLocation(prog, 'u_seed'), Math.random() * 1000);
            });
            this.gl.deleteTexture(texture);
            return this.getImageData();
        }

        gradient(width, height) {
            this.render(this.programs.gradient, width, height, (gl, prog) => {
                gl.uniform4f(gl.getUniformLocation(prog, 'u_tl'), Math.random(), Math.random(), Math.random(), 1);
                gl.uniform4f(gl.getUniformLocation(prog, 'u_tr'), Math.random(), Math.random(), Math.random(), 1);
                gl.uniform4f(gl.getUniformLocation(prog, 'u_bl'), Math.random(), Math.random(), Math.random(), 1);
                gl.uniform4f(gl.getUniformLocation(prog, 'u_br'), Math.random(), Math.random(), Math.random(), 1);
            });
            return this.getImageData();
        }
    }

    // ============================================
    // App State & Config
    // ============================================
    const effects = {
        shuffles: [
            { id: 'globalShuffle', name: 'Global Shuffle', gpu: false },
            { id: 'binedShuffle', name: 'Bined Shuffle', gpu: false },
            { id: 'localShuffle', name: 'Local Shuffle', gpu: true },
            { id: 'binedColorShuffle', name: 'Color Shuffle', gpu: false }
        ],
        transforms: [
            { id: 'invert', name: 'Invert', gpu: true },
            { id: 'boost', name: 'Boost', gpu: true },
            { id: 'gaussianBlur', name: 'Blur', gpu: true }
        ],
        creations: [
            { id: 'gradient', name: 'Gradient', gpu: true }
        ]
    };

    const settingsConfig = {
        globalShuffle: [{ id: 'outputSize', name: 'Size', min: 128, max: 1024, default: 512, step: 64 }],
        binedShuffle: [
            { id: 'outputSize', name: 'Size', min: 128, max: 1024, default: 512, step: 64 },
            { id: 'blockSize', name: 'Block', min: 4, max: 64, default: 16, step: 4 }
        ],
        localShuffle: [{ id: 'spread', name: 'Spread', min: 0, max: 100, default: 25, step: 1 }],
        binedColorShuffle: [
            { id: 'outputSize', name: 'Size', min: 128, max: 1024, default: 512, step: 64 },
            { id: 'blockSize', name: 'Block', min: 8, max: 64, default: 32, step: 8 }
        ],
        boost: [
            { id: 'boostRed', name: 'Red', min: 0, max: 100, default: 40, step: 5 },
            { id: 'boostGreen', name: 'Green', min: 0, max: 100, default: 30, step: 5 },
            { id: 'boostBlue', name: 'Blue', min: 0, max: 100, default: 20, step: 5 }
        ],
        gaussianBlur: [{ id: 'radius', name: 'Radius', min: 1, max: 30, default: 8, step: 1 }],
        gradient: [{ id: 'outputSize', name: 'Size', min: 128, max: 1024, default: 512, step: 64 }],
        invert: []
    };

    let state = {
        category: 'shuffles',
        effect: 'globalShuffle',
        settings: {},
        originalImageData: null,
        processedImageData: null,
        isProcessing: false
    };

    // DOM
    const $ = id => document.getElementById(id);
    const canvas = $('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const fileInput = $('fileInput');
    const placeholder = $('placeholder');
    const progressContainer = $('progressContainer');
    const progressFill = $('progressFill');
    const progressText = $('progressText');
    const perfStats = $('perfStats');
    const applyBtn = $('applyBtn');
    const downloadBtn = $('downloadBtn');
    const compareToggle = $('compareToggle');
    const compareSwitch = $('compareSwitch');

    // GPU Processor
    const gpu = new WebGLProcessor();

    // ============================================
    // UI Rendering
    // ============================================
    function renderCategories() {
        const container = $('categories');
        container.innerHTML = Object.keys(effects).map(cat =>
            `<button class="category-btn ${cat === state.category ? 'active' : ''}" data-cat="${cat}">
                ${cat.charAt(0).toUpperCase() + cat.slice(1)}
            </button>`
        ).join('');

        container.querySelectorAll('.category-btn').forEach(btn => {
            btn.onclick = () => {
                state.category = btn.dataset.cat;
                state.effect = effects[state.category][0].id;
                renderCategories();
                renderEffects();
                renderSettings();
            };
        });
    }

    function renderEffects() {
        const container = $('effectsContainer');
        container.innerHTML = effects[state.category].map(e =>
            `<button class="effect-btn ${e.id === state.effect ? 'active' : ''}" data-effect="${e.id}">
                ${e.name}${e.gpu && gpu.available ? ' âš¡' : ''}
            </button>`
        ).join('');

        container.querySelectorAll('.effect-btn').forEach(btn => {
            btn.onclick = () => {
                state.effect = btn.dataset.effect;
                renderEffects();
                renderSettings();
            };
        });
    }

    function renderSettings() {
        const config = settingsConfig[state.effect] || [];
        const container = $('settingsContainer');

        if (!config.length) {
            container.innerHTML = '<p style="font-size:0.75rem;color:var(--text-secondary)">No settings</p>';
            return;
        }

        container.innerHTML = config.map(s => {
            const val = state.settings[s.id] ?? s.default;
            return `<div class="setting-row">
                <label>${s.name}</label>
                <input type="range" id="s-${s.id}" min="${s.min}" max="${s.max}" value="${val}" step="${s.step}">
                <span id="v-${s.id}">${val}</span>
            </div>`;
        }).join('');

        config.forEach(s => {
            const input = $(`s-${s.id}`);
            const span = $(`v-${s.id}`);
            state.settings[s.id] = state.settings[s.id] ?? s.default;

            input.oninput = () => {
                state.settings[s.id] = +input.value;
                span.textContent = input.value;
            };
        });
    }

    // ============================================
    // Image Handling
    // ============================================
    function loadImage(file) {
        const reader = new FileReader();
        reader.onload = e => {
            const img = new Image();
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                state.originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                state.processedImageData = null;
                placeholder.style.display = 'none';
                canvas.style.display = 'block';
                applyBtn.disabled = false;
                downloadBtn.disabled = true;
                compareToggle.style.display = 'none';
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    function displayImage(imageData) {
        if (!imageData) return;
        canvas.width = imageData.width;
        canvas.height = imageData.height;
        ctx.putImageData(imageData, 0, 0);
    }

    function updateProgress(pct, text) {
        progressFill.style.width = `${pct}%`;
        progressText.textContent = text || `Processing... ${Math.round(pct)}%`;
    }

    // ============================================
    // CPU Processing (chunked for 60fps)
    // ============================================
    function processChunked(total, chunkSize, processFn) {
        return new Promise(resolve => {
            let i = 0;
            function chunk() {
                const end = Math.min(i + chunkSize, total);
                processFn(i, end);
                i = end;
                updateProgress((i / total) * 100);

                if (i < total) {
                    requestAnimationFrame(chunk);
                } else {
                    resolve();
                }
            }
            requestAnimationFrame(chunk);
        });
    }

    function resizeImageData(imageData, w, h) {
        const temp = document.createElement('canvas');
        temp.width = imageData.width;
        temp.height = imageData.height;
        temp.getContext('2d').putImageData(imageData, 0, 0);

        const out = document.createElement('canvas');
        out.width = w;
        out.height = h;
        out.getContext('2d').drawImage(temp, 0, 0, w, h);
        return out.getContext('2d').getImageData(0, 0, w, h);
    }

    // ============================================
    // Effect Implementations
    // ============================================
    async function globalShuffle() {
        const size = state.settings.outputSize || 512;
        const resized = resizeImageData(state.originalImageData, size, size);
        const data = new Uint8ClampedArray(resized.data);
        const total = size * size;

        // Optimized Fisher-Yates with typed arrays
        const indices = new Uint32Array(total);
        for (let i = 0; i < total; i++) indices[i] = i;

        await processChunked(total, 50000, (start, end) => {
            for (let i = end - 1; i >= start && i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }
        });

        const output = new Uint8ClampedArray(total * 4);
        for (let i = 0; i < total; i++) {
            const src = indices[i] * 4;
            const dst = i * 4;
            output[dst] = data[src];
            output[dst + 1] = data[src + 1];
            output[dst + 2] = data[src + 2];
            output[dst + 3] = data[src + 3];
        }

        return new ImageData(output, size, size);
    }

    async function binedShuffle() {
        const size = state.settings.outputSize || 512;
        const block = state.settings.blockSize || 16;
        const resized = resizeImageData(state.originalImageData, size, size);
        const data = new Uint8ClampedArray(resized.data);

        const blocksX = Math.floor(size / block);
        const blocksY = Math.floor(size / block);
        const totalBlocks = blocksX * blocksY;

        await processChunked(totalBlocks, 50, (start, end) => {
            for (let b = start; b < end; b++) {
                const bx = b % blocksX;
                const by = Math.floor(b / blocksX);

                const pixels = [];
                for (let ly = 0; ly < block; ly++) {
                    for (let lx = 0; lx < block; lx++) {
                        const x = bx * block + lx;
                        const y = by * block + ly;
                        const i = (y * size + x) * 4;
                        pixels.push([data[i], data[i+1], data[i+2], data[i+3]]);
                    }
                }

                // Shuffle
                for (let i = pixels.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [pixels[i], pixels[j]] = [pixels[j], pixels[i]];
                }

                // Write back
                let pi = 0;
                for (let ly = 0; ly < block; ly++) {
                    for (let lx = 0; lx < block; lx++) {
                        const x = bx * block + lx;
                        const y = by * block + ly;
                        const i = (y * size + x) * 4;
                        data[i] = pixels[pi][0];
                        data[i+1] = pixels[pi][1];
                        data[i+2] = pixels[pi][2];
                        data[i+3] = pixels[pi][3];
                        pi++;
                    }
                }
            }
        });

        return new ImageData(data, size, size);
    }

    async function binedColorShuffle() {
        const size = state.settings.outputSize || 512;
        const block = state.settings.blockSize || 32;
        const resized = resizeImageData(state.originalImageData, size, size);

        // Sample colors
        const colors = [];
        for (let i = 0; i < 100; i++) {
            const idx = Math.floor(Math.random() * size * size) * 4;
            colors.push(rgbToHsl(resized.data[idx]/255, resized.data[idx+1]/255, resized.data[idx+2]/255));
        }

        const data = new Uint8ClampedArray(size * size * 4);
        const blocksX = Math.floor(size / block);
        const blocksY = Math.floor(size / block);

        await processChunked(blocksX * blocksY, 20, (start, end) => {
            for (let b = start; b < end; b++) {
                const bx = b % blocksX;
                const by = Math.floor(b / blocksX);
                const base = colors[Math.floor(Math.random() * colors.length)];

                for (let ly = 0; ly < block; ly++) {
                    for (let lx = 0; lx < block; lx++) {
                        const x = bx * block + lx;
                        const y = by * block + ly;
                        const i = (y * size + x) * 4;

                        const s = Math.min(1, base.s * (1 + Math.random() * 0.5));
                        const l = Math.min(1, Math.max(0, base.l * Math.random() * 1.5));
                        const rgb = hslToRgb(base.h, s, l);

                        data[i] = Math.round(rgb.r * 255);
                        data[i+1] = Math.round(rgb.g * 255);
                        data[i+2] = Math.round(rgb.b * 255);
                        data[i+3] = 255;
                    }
                }
            }
        });

        return new ImageData(data, size, size);
    }

    // Color conversion helpers
    function rgbToHsl(r, g, b) {
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        const l = (max + min) / 2;
        if (max === min) return { h: 0, s: 0, l };
        const d = max - min;
        const s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        let h;
        if (max === r) h = (g - b) / d + (g < b ? 6 : 0);
        else if (max === g) h = (b - r) / d + 2;
        else h = (r - g) / d + 4;
        return { h: h / 6, s, l };
    }

    function hslToRgb(h, s, l) {
        if (s === 0) return { r: l, g: l, b: l };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        };
        return { r: hue2rgb(p, q, h + 1/3), g: hue2rgb(p, q, h), b: hue2rgb(p, q, h - 1/3) };
    }

    // ============================================
    // Apply Effect
    // ============================================
    async function applyEffect() {
        if (state.isProcessing || (!state.originalImageData && state.effect !== 'gradient')) return;

        state.isProcessing = true;
        document.body.classList.add('processing');
        applyBtn.disabled = true;
        progressContainer.classList.add('visible');
        updateProgress(0);

        const startTime = performance.now();
        let result;
        let usedGPU = false;

        try {
            const effectConfig = effects[state.category].find(e => e.id === state.effect);

            // Try GPU first if available
            if (gpu.available && effectConfig?.gpu) {
                usedGPU = true;
                switch (state.effect) {
                    case 'invert':
                        result = gpu.invert(state.originalImageData);
                        break;
                    case 'boost':
                        result = gpu.boost(state.originalImageData,
                            (state.settings.boostRed ?? 40) / 100,
                            (state.settings.boostGreen ?? 30) / 100,
                            (state.settings.boostBlue ?? 20) / 100);
                        break;
                    case 'gaussianBlur':
                        result = gpu.blur(state.originalImageData, state.settings.radius || 8);
                        break;
                    case 'localShuffle':
                        result = gpu.localShuffle(state.originalImageData, (state.settings.spread || 25) / 100);
                        break;
                    case 'gradient':
                        const size = state.settings.outputSize || 512;
                        result = gpu.gradient(size, size);
                        if (!state.originalImageData) {
                            state.originalImageData = new ImageData(new Uint8ClampedArray(result.data), size, size);
                            placeholder.style.display = 'none';
                            canvas.style.display = 'block';
                        }
                        break;
                }
            }

            // Fall back to CPU
            if (!result) {
                usedGPU = false;
                switch (state.effect) {
                    case 'globalShuffle': result = await globalShuffle(); break;
                    case 'binedShuffle': result = await binedShuffle(); break;
                    case 'localShuffle': result = await localShuffleCPU(); break;
                    case 'binedColorShuffle': result = await binedColorShuffle(); break;
                    case 'invert': result = await invertCPU(); break;
                    case 'boost': result = await boostCPU(); break;
                    case 'gaussianBlur': result = await blurCPU(); break;
                    case 'gradient': result = await gradientCPU(); break;
                }
            }

            const elapsed = performance.now() - startTime;
            perfStats.textContent = `${usedGPU ? 'GPU' : 'CPU'} Â· ${elapsed.toFixed(1)}ms`;

            state.processedImageData = result;
            displayImage(result);
            downloadBtn.disabled = false;
            compareToggle.style.display = 'flex';
            compareSwitch.checked = true;
            $('originalLabel').classList.remove('active');
            $('processedLabel').classList.add('active');

        } catch (err) {
            console.error(err);
            perfStats.textContent = 'Error processing';
        }

        updateProgress(100);
        setTimeout(() => {
            progressContainer.classList.remove('visible');
            state.isProcessing = false;
            document.body.classList.remove('processing');
            applyBtn.disabled = false;
        }, 300);
    }

    // CPU fallbacks for non-GPU effects
    async function localShuffleCPU() {
        const spread = (state.settings.spread || 25) / 100;
        const { width, height, data } = state.originalImageData;
        const maxSpread = Math.max(width, height) * spread / 4;
        const output = new Uint8ClampedArray(data);

        await processChunked(width * height, 20000, (start, end) => {
            for (let i = start; i < end; i++) {
                const x = i % width, y = Math.floor(i / width);
                const u1 = Math.random(), u2 = Math.random();
                const n = Math.sqrt(-2 * Math.log(Math.max(0.0001, u1))) * Math.cos(2 * Math.PI * u2);
                const ox = Math.round(n * maxSpread), oy = Math.round(n * maxSpread);
                const nx = Math.max(0, Math.min(width - 1, x + ox));
                const ny = Math.max(0, Math.min(height - 1, y + oy));
                const ni = ny * width + nx;
                for (let c = 0; c < 4; c++) {
                    const t = output[i * 4 + c];
                    output[i * 4 + c] = output[ni * 4 + c];
                    output[ni * 4 + c] = t;
                }
            }
        });
        return new ImageData(output, width, height);
    }

    async function invertCPU() {
        const { width, height, data } = state.originalImageData;
        const output = new Uint8ClampedArray(data.length);
        for (let i = 0; i < data.length; i += 4) {
            output[i] = 255 - data[i];
            output[i+1] = 255 - data[i+1];
            output[i+2] = 255 - data[i+2];
            output[i+3] = data[i+3];
        }
        return new ImageData(output, width, height);
    }

    async function boostCPU() {
        const { width, height, data } = state.originalImageData;
        const br = (state.settings.boostRed ?? 40) / 100;
        const bg = (state.settings.boostGreen ?? 30) / 100;
        const bb = (state.settings.boostBlue ?? 20) / 100;
        const output = new Uint8ClampedArray(data.length);

        let sr = 0, sg = 0, sb = 0;
        const n = width * height;
        for (let i = 0; i < data.length; i += 4) { sr += data[i]; sg += data[i+1]; sb += data[i+2]; }
        const mr = sr / n, mg = sg / n, mb = sb / n;

        let vr = 0, vg = 0, vb = 0;
        for (let i = 0; i < data.length; i += 4) {
            vr += (data[i] - mr) ** 2;
            vg += (data[i+1] - mg) ** 2;
            vb += (data[i+2] - mb) ** 2;
        }
        const dr = Math.sqrt(vr / n) || 1, dg = Math.sqrt(vg / n) || 1, db = Math.sqrt(vb / n) || 1;

        for (let i = 0; i < data.length; i += 4) {
            const r = (data[i] - mr) / dr * br;
            const g = (data[i+1] - mg) / dg * bg;
            const b = (data[i+2] - mb) / db * bb;
            output[i] = Math.round((Math.tanh(r * 4) + 1) / 2 * 255);
            output[i+1] = Math.round((Math.tanh(g * 4) + 1) / 2 * 255);
            output[i+2] = Math.round((Math.tanh(b * 4) + 1) / 2 * 255);
            output[i+3] = data[i+3];
        }
        return new ImageData(output, width, height);
    }

    async function blurCPU() {
        const radius = state.settings.radius || 8;
        const { width, height, data } = state.originalImageData;
        const kernel = [];
        const sigma = radius / 3;
        let sum = 0;
        for (let i = -radius; i <= radius; i++) {
            const v = Math.exp(-i * i / (2 * sigma * sigma));
            kernel.push(v);
            sum += v;
        }
        for (let i = 0; i < kernel.length; i++) kernel[i] /= sum;

        const temp = new Uint8ClampedArray(data.length);
        const output = new Uint8ClampedArray(data.length);

        // Horizontal
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                let r = 0, g = 0, b = 0, a = 0;
                for (let k = -radius; k <= radius; k++) {
                    const px = Math.min(width - 1, Math.max(0, x + k));
                    const idx = (y * width + px) * 4;
                    const w = kernel[k + radius];
                    r += data[idx] * w; g += data[idx+1] * w; b += data[idx+2] * w; a += data[idx+3] * w;
                }
                const idx = (y * width + x) * 4;
                temp[idx] = r; temp[idx+1] = g; temp[idx+2] = b; temp[idx+3] = a;
            }
            if (y % 20 === 0) { updateProgress(y / height * 50); await new Promise(r => setTimeout(r, 0)); }
        }

        // Vertical
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                let r = 0, g = 0, b = 0, a = 0;
                for (let k = -radius; k <= radius; k++) {
                    const py = Math.min(height - 1, Math.max(0, y + k));
                    const idx = (py * width + x) * 4;
                    const w = kernel[k + radius];
                    r += temp[idx] * w; g += temp[idx+1] * w; b += temp[idx+2] * w; a += temp[idx+3] * w;
                }
                const idx = (y * width + x) * 4;
                output[idx] = r; output[idx+1] = g; output[idx+2] = b; output[idx+3] = a;
            }
            if (y % 20 === 0) { updateProgress(50 + y / height * 50); await new Promise(r => setTimeout(r, 0)); }
        }

        return new ImageData(output, width, height);
    }

    async function gradientCPU() {
        const size = state.settings.outputSize || 512;
        const data = new Uint8ClampedArray(size * size * 4);
        const tl = { r: Math.random(), g: Math.random(), b: Math.random() };
        const tr = { r: Math.random(), g: Math.random(), b: Math.random() };
        const bl = { r: Math.random(), g: Math.random(), b: Math.random() };
        const br = { r: Math.random(), g: Math.random(), b: Math.random() };

        for (let y = 0; y < size; y++) {
            const fy = y / (size - 1);
            for (let x = 0; x < size; x++) {
                const fx = x / (size - 1);
                const top = { r: tl.r * (1-fx) + tr.r * fx, g: tl.g * (1-fx) + tr.g * fx, b: tl.b * (1-fx) + tr.b * fx };
                const bot = { r: bl.r * (1-fx) + br.r * fx, g: bl.g * (1-fx) + br.g * fx, b: bl.b * (1-fx) + br.b * fx };
                const i = (y * size + x) * 4;
                data[i] = Math.round((top.r * (1-fy) + bot.r * fy) * 255);
                data[i+1] = Math.round((top.g * (1-fy) + bot.g * fy) * 255);
                data[i+2] = Math.round((top.b * (1-fy) + bot.b * fy) * 255);
                data[i+3] = 255;
            }
        }

        if (!state.originalImageData) {
            state.originalImageData = new ImageData(new Uint8ClampedArray(data), size, size);
            placeholder.style.display = 'none';
            canvas.style.display = 'block';
        }

        return new ImageData(data, size, size);
    }

    // ============================================
    // Event Listeners
    // ============================================
    $('uploadBtn').onclick = () => fileInput.click();
    fileInput.onchange = e => e.target.files[0] && loadImage(e.target.files[0]);

    $('canvasContainer').ondragover = e => { e.preventDefault(); $('dropZone').classList.add('active'); };
    $('canvasContainer').ondragleave = () => $('dropZone').classList.remove('active');
    $('canvasContainer').ondrop = e => {
        e.preventDefault();
        $('dropZone').classList.remove('active');
        const file = e.dataTransfer.files[0];
        if (file?.type.startsWith('image/')) loadImage(file);
    };

    applyBtn.onclick = applyEffect;

    downloadBtn.onclick = () => {
        if (!state.processedImageData) return;
        const link = document.createElement('a');
        link.download = `madpixels-${state.effect}-${Date.now()}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
    };

    compareSwitch.onchange = () => {
        const show = compareSwitch.checked;
        $('originalLabel').classList.toggle('active', !show);
        $('processedLabel').classList.toggle('active', show);
        displayImage(show ? state.processedImageData : state.originalImageData);
    };

    // Init
    renderCategories();
    renderEffects();
    renderSettings();
    </script>
</body>
</html>
