<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MADpixels</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        :root {
            --bg: #ffffff;
            --text: #000000;
            --gray: #888888;
            --border: #e0e0e0;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
            background: var(--bg);
            color: var(--text);
            font-size: 13px;
        }

        .app {
            height: 100%;
            display: flex;
            flex-direction: column;
            max-width: 400px;
            margin: 0 auto;
            padding: 12px;
            gap: 12px;
        }

        /* Header */
        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .logo {
            font-size: 15px;
            font-weight: 600;
            letter-spacing: -0.3px;
        }

        .icon-btn {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: transparent;
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .icon-btn:active { background: var(--border); }
        .icon-btn:disabled { opacity: 0.3; }
        .icon-btn svg { width: 16px; height: 16px; }

        /* Gallery View */
        .gallery-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
        }

        .gallery-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            min-height: 0;
        }

        .gallery-item {
            aspect-ratio: 1;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            position: relative;
            border: 1px solid var(--border);
        }
        .gallery-item:active { opacity: 0.7; }

        .gallery-item canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .gallery-item-label {
            position: absolute;
            bottom: 6px;
            left: 6px;
            padding: 3px 6px;
            background: rgba(255,255,255,0.9);
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }

        .upload-btn {
            flex-shrink: 0;
            padding: 14px;
            border: 1px solid var(--text);
            border-radius: 8px;
            background: transparent;
            color: var(--text);
            font-family: inherit;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
        }
        .upload-btn:active { background: var(--text); color: var(--bg); }

        /* Editor View */
        .editor-view {
            display: none;
            flex: 1;
            flex-direction: column;
            gap: 10px;
            min-height: 0;
        }

        .editor-view.active { display: flex; }
        .gallery-view.hidden { display: none; }

        .canvas-wrap {
            flex: 1;
            min-height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            position: relative;
        }

        .canvas-wrap canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }

        .drop-zone {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.05);
            border: 2px dashed var(--text);
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: 500;
        }
        .drop-zone.active { display: flex; }

        /* Compare */
        .compare-row {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex-shrink: 0;
        }
        .compare-row.visible { display: flex; }

        .compare-label {
            font-size: 11px;
            color: var(--gray);
        }
        .compare-label.active { color: var(--text); font-weight: 500; }

        .toggle {
            width: 40px;
            height: 22px;
            background: var(--border);
            border-radius: 11px;
            position: relative;
            cursor: pointer;
        }
        .toggle.on { background: var(--text); }

        .toggle-knob {
            position: absolute;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.15s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .toggle.on .toggle-knob { transform: translateX(18px); }

        /* Controls */
        .controls {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .effects-row {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .effect-btn {
            padding: 6px 10px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: transparent;
            color: var(--gray);
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
        }
        .effect-btn:active { background: var(--border); }
        .effect-btn.active {
            border-color: var(--text);
            color: var(--text);
            font-weight: 500;
        }

        .param-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .param-label {
            font-size: 12px;
            color: var(--gray);
        }

        .param-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .param-value {
            font-size: 12px;
            min-width: 28px;
            text-align: right;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 80px;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            cursor: pointer;
        }

        .apply-btn {
            padding: 14px;
            border: none;
            border-radius: 8px;
            background: var(--text);
            color: var(--bg);
            font-family: inherit;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
        }
        .apply-btn:active { opacity: 0.8; }
        .apply-btn:disabled { background: var(--border); color: var(--gray); }

        .progress-row {
            display: none;
            flex-direction: column;
            gap: 6px;
        }
        .progress-row.visible { display: flex; }

        .progress-bar {
            height: 3px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--text);
            width: 0%;
            transition: width 0.1s;
        }

        .progress-text {
            font-size: 11px;
            color: var(--gray);
            text-align: center;
        }

        .hidden { display: none !important; }
        .params-section.hidden { display: none; }
    </style>
</head>
<body>
    <div class="app">
        <header>
            <span class="logo">MADpixels</span>
            <button class="icon-btn" id="downloadBtn" disabled>
                <svg fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
                </svg>
            </button>
        </header>

        <div class="gallery-view" id="galleryView">
            <div class="gallery-grid" id="galleryGrid"></div>
            <button class="upload-btn" id="choosePhotoBtn">Upload Photo</button>
        </div>

        <div class="editor-view" id="editorView">
            <div class="canvas-wrap" id="canvasArea">
                <canvas id="canvas"></canvas>
                <canvas id="glCanvas" class="hidden"></canvas>
                <div class="drop-zone" id="dropZone">Drop</div>
            </div>

            <div class="compare-row" id="compareBar">
                <span class="compare-label" id="labelOriginal">Before</span>
                <div class="toggle on" id="toggle"><div class="toggle-knob"></div></div>
                <span class="compare-label active" id="labelProcessed">After</span>
            </div>

            <div class="controls">
                <div class="effects-row" id="effectsRow"></div>
                <div class="params-section" id="settingsSection">
                    <div id="settingsContainer"></div>
                </div>
                <div class="progress-row" id="progressSection">
                    <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
                    <div class="progress-text" id="progressText">Processing...</div>
                </div>
                <button class="apply-btn" id="applyBtn">Apply</button>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept="image/*" style="display:none">

<script>
class WebGLProcessor {
    constructor() {
        this.canvas = document.getElementById('glCanvas');
        this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl');
        this.programs = {};
        this.available = !!this.gl;
        if (this.available) this.init();
    }

    init() {
        const gl = this.gl;
        const vert = `attribute vec2 a_position;attribute vec2 a_texCoord;varying vec2 v_texCoord;void main(){gl_Position=vec4(a_position,0,1);v_texCoord=a_texCoord;}`;
        const shaders = {
            invert: `precision mediump float;varying vec2 v_texCoord;uniform sampler2D u_image;void main(){vec4 c=texture2D(u_image,v_texCoord);gl_FragColor=vec4(1.0-c.rgb,c.a);}`,
            boost: `precision mediump float;varying vec2 v_texCoord;uniform sampler2D u_image;uniform vec3 u_boost;vec3 tanh3(vec3 x){vec3 e=exp(2.0*x);return(e-1.0)/(e+1.0);}void main(){vec4 c=texture2D(u_image,v_texCoord);vec3 n=(c.rgb-0.5)*u_boost*4.0;gl_FragColor=vec4((tanh3(n)+1.0)*0.5,c.a);}`,
            blur: `precision mediump float;varying vec2 v_texCoord;uniform sampler2D u_image;uniform vec2 u_res;uniform float u_rad;uniform vec2 u_dir;void main(){vec4 s=vec4(0.0);float t=0.0;for(float i=-20.0;i<=20.0;i+=1.0){float w=exp(-i*i/(2.0*u_rad*u_rad));s+=texture2D(u_image,v_texCoord+u_dir*i/u_res)*w;t+=w;}gl_FragColor=s/t;}`,
            localShuffle: `precision highp float;varying vec2 v_texCoord;uniform sampler2D u_image;uniform vec2 u_res;uniform float u_spread;uniform float u_seed;float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453+u_seed);}void main(){float m=max(u_res.x,u_res.y)*u_spread/4.0;float u1=max(0.0001,hash(v_texCoord*u_res));float u2=hash(v_texCoord*u_res+vec2(1.0,0.0));float r=sqrt(-2.0*log(u1));vec2 n=vec2(r*cos(6.28318*u2),r*sin(6.28318*u2))*m/u_res;gl_FragColor=texture2D(u_image,clamp(v_texCoord+n,0.0,1.0));}`,
            gradient: `precision mediump float;varying vec2 v_texCoord;uniform vec4 u_tl,u_tr,u_bl,u_br;void main(){gl_FragColor=mix(mix(u_tl,u_tr,v_texCoord.x),mix(u_bl,u_br,v_texCoord.x),v_texCoord.y);}`
        };
        for (const [name, frag] of Object.entries(shaders)) {
            const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, vert); gl.compileShader(vs);
            const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, frag); gl.compileShader(fs);
            const prog = gl.createProgram(); gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog);
            this.programs[name] = prog;
        }
        this.posBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);
        this.texBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,1,1,1,0,0,0,0,1,1,1,0]), gl.STATIC_DRAW);
    }

    createTexture(img) {
        const gl = this.gl, tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        return tex;
    }

    render(prog, w, h, setup) {
        const gl = this.gl;
        this.canvas.width = w; this.canvas.height = h;
        gl.viewport(0, 0, w, h); gl.useProgram(prog);
        const pLoc = gl.getAttribLocation(prog, 'a_position');
        gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuf); gl.enableVertexAttribArray(pLoc); gl.vertexAttribPointer(pLoc, 2, gl.FLOAT, false, 0, 0);
        const tLoc = gl.getAttribLocation(prog, 'a_texCoord');
        gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuf); gl.enableVertexAttribArray(tLoc); gl.vertexAttribPointer(tLoc, 2, gl.FLOAT, false, 0, 0);
        setup(gl, prog); gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    getImageData() {
        const gl = this.gl, w = this.canvas.width, h = this.canvas.height;
        const px = new Uint8Array(w * h * 4);
        gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, px);
        const flip = new Uint8ClampedArray(px.length);
        for (let y = 0; y < h; y++) flip.set(px.subarray((h-1-y)*w*4, (h-y)*w*4), y*w*4);
        return new ImageData(flip, w, h);
    }

    gradient(w, h, colors) {
        this.render(this.programs.gradient, w, h, (gl, p) => {
            gl.uniform4f(gl.getUniformLocation(p, 'u_tl'), colors.tl[0], colors.tl[1], colors.tl[2], 1);
            gl.uniform4f(gl.getUniformLocation(p, 'u_tr'), colors.tr[0], colors.tr[1], colors.tr[2], 1);
            gl.uniform4f(gl.getUniformLocation(p, 'u_bl'), colors.bl[0], colors.bl[1], colors.bl[2], 1);
            gl.uniform4f(gl.getUniformLocation(p, 'u_br'), colors.br[0], colors.br[1], colors.br[2], 1);
        });
        return this.getImageData();
    }

    invert(img) { const t = this.createTexture(img); this.render(this.programs.invert, img.width, img.height, (gl, p) => { gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, t); gl.uniform1i(gl.getUniformLocation(p, 'u_image'), 0); }); this.gl.deleteTexture(t); return this.getImageData(); }
    boost(img, r, g, b) { const t = this.createTexture(img); this.render(this.programs.boost, img.width, img.height, (gl, p) => { gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, t); gl.uniform1i(gl.getUniformLocation(p, 'u_image'), 0); gl.uniform3f(gl.getUniformLocation(p, 'u_boost'), r, g, b); }); this.gl.deleteTexture(t); return this.getImageData(); }
    blur(img, rad) { const gl = this.gl; let t = this.createTexture(img); this.render(this.programs.blur, img.width, img.height, (gl, p) => { gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, t); gl.uniform1i(gl.getUniformLocation(p, 'u_image'), 0); gl.uniform2f(gl.getUniformLocation(p, 'u_res'), img.width, img.height); gl.uniform1f(gl.getUniformLocation(p, 'u_rad'), rad); gl.uniform2f(gl.getUniformLocation(p, 'u_dir'), 1, 0); }); const mid = this.getImageData(); gl.deleteTexture(t); t = this.createTexture(mid); this.render(this.programs.blur, img.width, img.height, (gl, p) => { gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, t); gl.uniform1i(gl.getUniformLocation(p, 'u_image'), 0); gl.uniform2f(gl.getUniformLocation(p, 'u_res'), img.width, img.height); gl.uniform1f(gl.getUniformLocation(p, 'u_rad'), rad); gl.uniform2f(gl.getUniformLocation(p, 'u_dir'), 0, 1); }); gl.deleteTexture(t); return this.getImageData(); }
    localShuffle(img, spread) { const t = this.createTexture(img); this.render(this.programs.localShuffle, img.width, img.height, (gl, p) => { gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, t); gl.uniform1i(gl.getUniformLocation(p, 'u_image'), 0); gl.uniform2f(gl.getUniformLocation(p, 'u_res'), img.width, img.height); gl.uniform1f(gl.getUniformLocation(p, 'u_spread'), spread); gl.uniform1f(gl.getUniformLocation(p, 'u_seed'), Math.random() * 1000); }); this.gl.deleteTexture(t); return this.getImageData(); }
}

const effects = [
    { id: 'localShuffle', name: 'Disperse', gpu: true },
    { id: 'globalShuffle', name: 'Shuffle', gpu: false },
    { id: 'binedShuffle', name: 'Blocks', gpu: false },
    { id: 'invert', name: 'Invert', gpu: true },
    { id: 'boost', name: 'Boost', gpu: true },
    { id: 'gaussianBlur', name: 'Blur', gpu: true }
];

const settingsConfig = {
    globalShuffle: [{ id: 'size', name: 'Size', min: 256, max: 1024, default: 512, step: 128 }],
    binedShuffle: [{ id: 'size', name: 'Size', min: 256, max: 1024, default: 512, step: 128 }, { id: 'block', name: 'Block', min: 8, max: 64, default: 16, step: 8 }],
    localShuffle: [{ id: 'spread', name: 'Spread', min: 0, max: 100, default: 25, step: 5 }],
    boost: [{ id: 'red', name: 'Warm', min: 0, max: 100, default: 40, step: 5 }, { id: 'green', name: 'Tint', min: 0, max: 100, default: 30, step: 5 }, { id: 'blue', name: 'Cool', min: 0, max: 100, default: 20, step: 5 }],
    gaussianBlur: [{ id: 'radius', name: 'Radius', min: 1, max: 30, default: 8, step: 1 }],
    invert: []
};

const presets = [
    { name: 'Warm', colors: { tl: [1, 0.6, 0.4], tr: [1, 0.8, 0.5], bl: [0.8, 0.4, 0.3], br: [0.9, 0.5, 0.4] } },
    { name: 'Cool', colors: { tl: [0.3, 0.5, 0.7], tr: [0.4, 0.6, 0.8], bl: [0.2, 0.3, 0.5], br: [0.3, 0.4, 0.6] } },
    { name: 'Mono', colors: { tl: [0.9, 0.9, 0.9], tr: [0.7, 0.7, 0.7], bl: [0.5, 0.5, 0.5], br: [0.3, 0.3, 0.3] } },
    { name: 'Vivid', colors: { tl: [1, 0.3, 0.5], tr: [0.3, 0.8, 1], bl: [0.5, 0.2, 0.7], br: [0.2, 0.6, 0.5] } }
];

let state = { effect: 'localShuffle', settings: {}, original: null, processed: null, processing: false };

const $ = id => document.getElementById(id);
const canvas = $('canvas'), ctx = canvas.getContext('2d', { willReadFrequently: true });
const gpu = new WebGLProcessor();

function generateGallery() {
    const grid = $('galleryGrid');
    grid.innerHTML = '';
    presets.forEach(preset => {
        const item = document.createElement('div');
        item.className = 'gallery-item';
        const c = document.createElement('canvas');
        c.width = 150; c.height = 150;
        c.getContext('2d').putImageData(gpu.gradient(150, 150, preset.colors), 0, 0);
        const label = document.createElement('div');
        label.className = 'gallery-item-label';
        label.textContent = preset.name;
        item.appendChild(c);
        item.appendChild(label);
        item.onclick = () => {
            state.original = gpu.gradient(512, 512, preset.colors);
            state.processed = null;
            showEditor();
        };
        grid.appendChild(item);
    });
}

function showEditor() {
    $('galleryView').classList.add('hidden');
    $('editorView').classList.add('active');
    display(state.original);
    $('compareBar').classList.remove('visible');
    $('downloadBtn').disabled = true;
}

function renderEffects() {
    $('effectsRow').innerHTML = effects.map(e =>
        `<button class="effect-btn ${e.id === state.effect ? 'active' : ''}" data-id="${e.id}">${e.name}</button>`
    ).join('');
    $('effectsRow').querySelectorAll('.effect-btn').forEach(btn => {
        btn.onclick = () => { state.effect = btn.dataset.id; renderEffects(); renderSettings(); };
    });
}

function renderSettings() {
    const cfg = settingsConfig[state.effect] || [];
    if (!cfg.length) { $('settingsSection').classList.add('hidden'); return; }
    $('settingsSection').classList.remove('hidden');
    $('settingsContainer').innerHTML = cfg.map(s => {
        const val = state.settings[s.id] ?? s.default;
        return `<div class="param-row"><span class="param-label">${s.name}</span><div class="param-control"><input type="range" id="r-${s.id}" min="${s.min}" max="${s.max}" value="${val}" step="${s.step}"><span class="param-value" id="v-${s.id}">${val}</span></div></div>`;
    }).join('');
    cfg.forEach(s => {
        state.settings[s.id] = state.settings[s.id] ?? s.default;
        const inp = $(`r-${s.id}`), val = $(`v-${s.id}`);
        inp.oninput = () => { state.settings[s.id] = +inp.value; val.textContent = inp.value; };
    });
}

function loadImage(file) {
    const reader = new FileReader();
    reader.onload = e => {
        const img = new Image();
        img.onload = () => {
            canvas.width = img.width; canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            state.original = ctx.getImageData(0, 0, canvas.width, canvas.height);
            state.processed = null;
            showEditor();
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

function display(data) {
    if (!data) return;
    canvas.width = data.width; canvas.height = data.height;
    ctx.putImageData(data, 0, 0);
}

function updateProgress(pct) {
    $('progressFill').style.width = pct + '%';
    $('progressText').textContent = pct < 100 ? 'Processing...' : 'Done';
}

function resize(img, w, h) {
    const c1 = document.createElement('canvas'); c1.width = img.width; c1.height = img.height; c1.getContext('2d').putImageData(img, 0, 0);
    const c2 = document.createElement('canvas'); c2.width = w; c2.height = h; c2.getContext('2d').drawImage(c1, 0, 0, w, h);
    return c2.getContext('2d').getImageData(0, 0, w, h);
}

async function chunk(total, size, fn) {
    return new Promise(resolve => {
        let i = 0;
        function step() {
            const end = Math.min(i + size, total);
            fn(i, end); i = end; updateProgress(Math.round(i / total * 100));
            i < total ? requestAnimationFrame(step) : resolve();
        }
        requestAnimationFrame(step);
    });
}

async function globalShuffle() {
    const s = state.settings.size || 512, img = resize(state.original, s, s), d = new Uint8ClampedArray(img.data), n = s * s;
    const idx = new Uint32Array(n); for (let i = 0; i < n; i++) idx[i] = i;
    await chunk(n, 50000, (a, b) => { for (let i = b - 1; i >= a && i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [idx[i], idx[j]] = [idx[j], idx[i]]; } });
    const out = new Uint8ClampedArray(n * 4);
    for (let i = 0; i < n; i++) { const src = idx[i] * 4, dst = i * 4; out[dst] = d[src]; out[dst+1] = d[src+1]; out[dst+2] = d[src+2]; out[dst+3] = d[src+3]; }
    return new ImageData(out, s, s);
}

async function binedShuffle() {
    const s = state.settings.size || 512, b = state.settings.block || 16, img = resize(state.original, s, s), d = new Uint8ClampedArray(img.data);
    const bx = Math.floor(s / b), total = bx * bx;
    await chunk(total, 50, (start, end) => {
        for (let bi = start; bi < end; bi++) {
            const x0 = (bi % bx) * b, y0 = Math.floor(bi / bx) * b, px = [];
            for (let y = 0; y < b; y++) for (let x = 0; x < b; x++) { const i = ((y0 + y) * s + x0 + x) * 4; px.push([d[i], d[i+1], d[i+2], d[i+3]]); }
            for (let i = px.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [px[i], px[j]] = [px[j], px[i]]; }
            let pi = 0;
            for (let y = 0; y < b; y++) for (let x = 0; x < b; x++) { const i = ((y0 + y) * s + x0 + x) * 4; d[i] = px[pi][0]; d[i+1] = px[pi][1]; d[i+2] = px[pi][2]; d[i+3] = px[pi][3]; pi++; }
        }
    });
    return new ImageData(d, s, s);
}

async function applyEffect() {
    if (state.processing || !state.original) return;
    state.processing = true;
    $('applyBtn').disabled = true;
    $('progressSection').classList.add('visible');
    updateProgress(0);

    let result, usedGPU = false;
    const eff = effects.find(e => e.id === state.effect);

    try {
        if (gpu.available && eff?.gpu) {
            usedGPU = true;
            if (state.effect === 'invert') result = gpu.invert(state.original);
            else if (state.effect === 'boost') result = gpu.boost(state.original, (state.settings.red ?? 40) / 100, (state.settings.green ?? 30) / 100, (state.settings.blue ?? 20) / 100);
            else if (state.effect === 'gaussianBlur') result = gpu.blur(state.original, state.settings.radius || 8);
            else if (state.effect === 'localShuffle') result = gpu.localShuffle(state.original, (state.settings.spread || 25) / 100);
        }
        if (!result) {
            if (state.effect === 'globalShuffle') result = await globalShuffle();
            else if (state.effect === 'binedShuffle') result = await binedShuffle();
        }

        state.processed = result;
        display(result);
        $('downloadBtn').disabled = false;
        $('compareBar').classList.add('visible');
        $('toggle').classList.add('on');
        $('labelOriginal').classList.remove('active');
        $('labelProcessed').classList.add('active');
    } catch (e) { console.error(e); }

    updateProgress(100);
    setTimeout(() => {
        $('progressSection').classList.remove('visible');
        state.processing = false;
        $('applyBtn').disabled = false;
    }, 300);
}

$('choosePhotoBtn').onclick = () => $('fileInput').click();
$('canvasArea').onclick = () => $('fileInput').click();
$('fileInput').onchange = e => e.target.files[0] && loadImage(e.target.files[0]);

$('canvasArea').ondragover = e => { e.preventDefault(); $('dropZone').classList.add('active'); };
$('canvasArea').ondragleave = () => $('dropZone').classList.remove('active');
$('canvasArea').ondrop = e => { e.preventDefault(); $('dropZone').classList.remove('active'); const f = e.dataTransfer.files[0]; if (f?.type.startsWith('image/')) loadImage(f); };

$('applyBtn').onclick = applyEffect;
$('downloadBtn').onclick = () => { if (!state.processed) return; const a = document.createElement('a'); a.download = `madpixels-${Date.now()}.png`; a.href = canvas.toDataURL('image/png'); a.click(); };

$('toggle').onclick = () => {
    const on = $('toggle').classList.toggle('on');
    $('labelOriginal').classList.toggle('active', !on);
    $('labelProcessed').classList.toggle('active', on);
    display(on ? state.processed : state.original);
};

generateGallery();
renderEffects();
renderSettings();
</script>
</body>
</html>
